---
layout: post
title: "数据库事务隔离级别解释"
title2: "数据库事务隔离级别解释"
date: 2018-11-02 02:18:26  +0800
source: "https://blog.csdn.net/JIESA/article/details/51317164"
fileName: "2ff5dc6"
lang: "zh_CN"
published: false
---

## 一、数据库事务隔离级别

数据库事务的隔离级别有 4 个，由低到高依次为 Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读  、不可重复读  、幻读 这几类问题。

√: 可能出现     ×: 不会出现

<table cellpadding="4" width="90%" cellspacing="0" border="1"><tbody><tr><td><span></span></td><td><span>脏读</span></td><td><span>不可重复读</span></td><td><span>幻读</span></td></tr><tr><td><span>Read uncommitted</span></td><td><span>√</span></td><td><span>√</span></td><td><span>√</span></td></tr><tr><td><span>Read committed</span></td><td><span>×</span></td><td><span>√</span></td><td><span>√</span></td></tr><tr><td><span>Repeatable read</span></td><td><span>×</span></td><td><span>×</span></td><td><span>√</span></td></tr><tr><td><span>Serializable</span></td><td><span>×</span></td><td><span>×</span></td><td><span>×</span></td></tr></tbody></table>

注意：我们讨论隔离级别的场景，主要是在多个事务并发   的情况下，因此，接下来的讲解都围绕事务并发。

##### Read uncommitted 读未提交

公司发工资了，领导把 5000 元打到 singo 的账号上，但是该事务并未提交，而 singo 正好去查看账户，发现工资已经到账，是 5000 元整，非常高 兴。可是不幸的是，领导发现发给 singo 的工资金额不对，是 2000 元，于是迅速回滚了事务，修改金额后，将事务提交，最后 singo 实际的工资只有 2000 元，singo 空欢喜一场。

![](http://dl.iteye.com/upload/attachment/556524/f244ae46-c8f4-3bc1-906e-d1d9c1af3516.gif)

出现上述情况，即我们所说的脏读  ，两个并发的事务，“事务 A：领导给 singo 发工资”、“事务 B：singo 查询工资账户”，事务 B 读取了事务 A 尚未提交的数据。

当隔离级别设置为 Read uncommitted  时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。

##### Read committed 读提交

singo 拿着工资卡去消费，系统读取到卡里确实有 2000 元，而此时她的老婆也正好在网上转账，把 singo 工资卡的 2000 元转到另一账户，并在 singo 之前提交了事务，当 singo 扣款时，系统检查到 singo 的工资卡已经没有钱，扣款失败，singo 十分纳闷，明明卡里有钱，为 何......

出现上述情况，即我们所说的不可重复读  ，两个并发的事务，“事务 A：singo 消费”、“事务 B：singo 的老婆网上转账”，事务 A 事先读取了数据，事务 B 紧接了更新了数据，并提交了事务，而事务 A 再次读取该数据时，数据已经发生了改变。

当隔离级别设置为 Read committed  时，避免了脏读，但是可能会造成不可重复读。

大多数数据库的默认级别就是 Read committed，比如 Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。

##### Repeatable read 重复读

当隔离级别设置为 Repeatable read  时，可以避免不可重复读。当 singo 拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo 的老婆就不可能对该记录进行修改，也就是 singo 的老婆不能在此时转账。

虽然 Repeatable read 避免了不可重复读，但还有可能出现幻读  。

singo 的老婆工作在银行部门，她时常通过银行内部系统查看 singo 的信用卡消费记录。有一天，她正在查询到 singo 当月信用卡的总消费金额 （select sum(amount) from transaction where month = 本月）为 80 元，而 singo 此时正好在外面胡吃海塞后在收银台买单，消费 1000 元，即新增了一条 1000 元的消费记录（insert transaction ... ），并提交了事务，随后 singo 的老婆将 singo 当月信用卡消费的明细打印到 A4 纸上，却发现消费总额为 1080 元，singo 的老婆很诧异，以为出 现了幻觉，幻读就这样产生了。

注：Mysql 的默认隔离级别就是 Repeatable read。

##### Serializable 序列化

Serializable  是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。

\***\*二、**脏读、幻读、不可重复读  
\*\*

**1.脏读：**  
脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

**2.不可重复读：**  
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）  
例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。

**3.幻读:**  
是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象  
发生了幻觉一样。  
例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。
